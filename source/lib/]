#include "network.hpp"
#include "map.hpp"
#include <fstream>
#include <climits>
#include <cstdint>


RoundSettings* RoundSettings::instance = nullptr;


RoundSettings::RoundSettings()
{
     if (instance == nullptr)
     {
         instance = this;
         isPlayer = true; // Reset this manually if you are the server. Don't do it otherwise.
         port = ANTNET_DEFAULT_PORT;
         mapFile = "defaultMap";
         configFile = "";
         gameStartDelay = 3.0;
     }
}


void RoundSettings::loadConfig(std::string config)
{
    std::ifstream configF;
    if (config != "")
    {
        configF.open(config, std::ios::in);
        if (!configFile.is_open())
        {
            std::cerr << "Cannot open file `" << config << "'. It might not exist or it might not be readable." << std::endl;
            if (config != "antgame.cfg")
            {
                configF.open("antgame.cfg", std::ios::in);
            }
            configFile = "antgame.cfg";
        }
        else {configFile = config;}
    }
    // Default settings. These are set here even if there is a config file, in case not all configs are set in there.
    mapFile = "defaultMap";
    port = ANTNET_DEFAULT_PORT;
    gameStartDelay = 3.0;
    timeScale = 1.0;
    if (configFile.is_open())
    {
        // TODO: Read config file
        std::string line;
        while (getline(configF, line))
        {
            std::string identifier = line.substr(0, line.find(':'));
            std::string data = line.find(':') >= line.length() - 1 ? "": line.substr(line.find(':')+1);
            configLine(identifier, data);
        }
    }
    configF.close();
}


void Round::configLine(std::string identifier, std::string data)
{
    if (identifier == "map")
    {
	mapFile = data;
    }
    else if (identifier == "timescale")
    {
	try{
	timeScale = std::stod(data);
	}except(...){
	timeScale = 1.0;
	std::cerr << "The `timescale' argument of the configuration file is not a valid floating point number! Remember not to include any spaces." << std::endl;
	}
    }
    else if (identifier == "port")
    {
	try{
	port = (unsigned int)std::stoi(data);
	}except(...){
	port = ANTNET_DEFAULT_PORT;
	std::cerr << "The `port' argument of the configuration file is not a valid integer! Remember not to include any spaces." << std::endl;
	}
    }
    else if (identifier == "gamestartdelay")
    {
	try{
	gameStartDelay = (unsigned int)std::stod(data);
	}except(...){
        gameStartDelay = 3.0;
	std::cerr << "The `gamestartdelay' argument of the configuration file is not a valid integer! Remember not to include any spaces." << std::endl;
	}
    }
}


Player::Player()
{
    timeAtLastMessage = std::chrono::steady_clock::now();
}


Player::Player(Connection*nconn)
{
    conn = nconn;
    timeAtLastMessage = std::chrono::steady_clock::now();
}


Player::Player(Viewer v)
{
    conn = v.conn;
    timeAtLastMessage = std::chrono::steady_clock::now();
    unusedData = v.unusedData;
}


Player::~Player()
{
    if (conn != nullptr)
    {
        delete conn;
    }
}


Viewer::Viewer()
{
    timeAtLastMessage = std::chrono::steady_clock::now();
}


Viewer::Viewer(Connection*nconn)
{
    conn = nconn;
    timeAtLastMessage = std::chrono::steady_clock::now();
}


Viewer::~Viewer()
{
    if (conn != nullptr)
    {
        delete conn;
    }
}


ConnectionManager::ConnectionManager() {}


void ConnectionManager::step()
{
    switch (Round::instance->phase)
    {
        case Round::Phase::INIT:
            return;
        case Round::Phase::WAIT:
            if (Connection::listening())
            {
                std::vector<Connection*> newConnections;
                if (Connection::fetchConnections(&newConnections) < 0)
                {
                    break;
                }
                for (int i = 0; i < newConnections.size(); i++)
                {
                    if (newConnections[i] == nullptr) {continue;}
                    if (!newConnections[i]->connected())
                    {
                        newConnections[i]->finish();
                        delete newConnections[i];
                    }
                    else
                    {
                        viewers.push_front(new Viewer(newConnections[i]));
                    }
                }
            }
            else
            {
                if (!Connection::openListen() && Connection::serrorState != Connection::RETRY)
                {
                    std::cerr << "Cannot listen for connections!"
                    // TODO
                }
            }
            break;
    }
    handleViewers();
}


void ConnectionManager::reset()
{
    for (Viewer* v : viewers)
    {
        if (v)
        {
	    delete v;
        }
    }
    viewers.clear();
    for (Player* p : players)
    {
        if (p)
        {
            delete p;
        }
    }
    players.clear();
}


void ConnectionManager::handleViewers()
{
    switch (Round::instance->phase)
    {
        case Round::Phase::WAIT:{
            for (Player* p : players)
            {
                p->toClose = !interpretRequests(p);
            }
            for (Viewer* v : viewers)
            {
                if (v->confirmed)
                {
                    httpResponse(v);
                }
                else if (httpResponse(v))
                {
                    v->confirmed = true;
                    v->timeAtLastMessage = std::chrono::steady_clock::now();
                }
                else if (playerGreeting(v))
                {
                    Player* p = new Player(*v);
                    p->nestID = players.size();
                    players.push_back(p);
                    v->conn = nullptr; // So the destructor doesn't kill it
                    v->toClose = true;
                }
            }
            break;}
        case Round::Phase::RUNNING:{
            for (
            break;}
    }
    auto prev = viewers.before_begin();
    bool del = false;
    std::chrono::steady_clock::time_point timpont = std::chrono::steady_clock::now();
    for (auto it = viewers.begin(); it != viewers.end(); it++)
    {
        if (del)
        {
            viewers.erase_after(prev);
        }
        else
        {
            prev++;
        }
        del = false;
        Viewer* v = *it;
        if (!isValid(v) || std::chrono::duration<double>(timpont - v->timeAtLastMessage).count() >= 1.0) {del = true;}
    }
}


bool ConnectionManager::isValid(Viewer* v)
{
    return v != nullptr && !v->toClose && v->conn != nullptr && v->conn->errorState != Connection::CLOSED && v->conn->connected();
}


bool ConnectionManager::isValid(Player* p)
{
    return p != nullptr && !p->toClose && p->conn != nullptr && p->conn->errorState != Connection::CLOSED && p->conn->connected();
}


bool ConnectionManager::httpResponse(Viewer* v)
{
    if (!isValid(v))
    {
        return false;
    }
    std::string data = v->unusedData;
    data += v->conn->readall();
    if (v->confirmed) // Deleting any leftover data before the next request (i.e. the message body)
    {
        size_t p = data.find("HTTP/1.1\r\n");
        if (p != std::string::npos)
        {
            p = data.rfind("\n", p);
            if (p != std::string::npos)
            {
                data.erase(0, p + 1);
            }
        }
        else
        {
            data.clear();
        }
    }
    if (data.find("\r\n") == std::string::npos)
    {
        v->unusedData = data;
        return false;
    }
    if (data.compare(data.find("\r\n") - 8, 8, "HTTP/1.1") == 0)
    {
        signed char flag = 0;
        if (data.compare(0, 4, "GET ") == 0)
        {
            flag = 2;
        }
        else if (data.compare(0, 5, "HEAD ") == 0)
        {
            flag = 1;
        }
	if (data.compare(0, 5, "POST ") == 0 || data.compare(0, 4, "PUT ") == 0 || data.compare(0, 7, "DELETE ") == 0 || data.compare(0, 8, "CONNECT ") == 0 || data.compare(0, 8, "OPTIONS") == 0 || data.compare(0, 6, "TRACE ") == 0 || data.compare(0, 6, "PATCH ") == 0)
        {
            sendResponse(v, "HTTP/1.1 405 Method Not Allowed\r\nConnection: keep-alive\r\n", "HTTPFiles/err405.html");
            data.erase(data.begin(), data.begin() + data.find("\r\n\r\n") + 4);
            v->unusedData = data;
            return true;
        }
        if (flag == 0)
        {
            sendResponse(v, "HTTP/1.1 400 Bad Request\r\nConnection: close\r\n", "HTTPFiles/err400.html");
            data.erase(data.begin(), data.begin() + data.find("\r\n\r\n") + 4);
            v->unusedData = data;
            v->toClose = true;
            return false;
        }
        if (data.compare(data.find(' ') + 1, 12, "/favicon.ico") == 0)
        {
            sendResponse(v, "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\n", flag == 2 ? "HTTPFiles/favicon.ico" : "");
            data.erase(data.begin(), data.begin() + data.find("\r\n\r\n") + 4);
            v->unusedData = data;
        }
        else if (data.compare(data.find(' ') + 1, 2, "/ ") != 0)
        {
            sendResponse(v, "HTTP/1.1 301 Moved Permanently\r\nLocation: /\r\nConnection: keep-alive\r\n", "");
            data.erase(data.begin(), data.begin() + data.find("\r\n\r\n") + 4);
            v->unusedData = data;
        }
        else
        {
            v->timeAtLastMessage = std::chrono::steady_clock::now();
	    data.erase(data.begin(), data.begin() + data.find("\r\n\r\n") + 4);
	    v->unusedData = data;
            switch (Round::instance->phase)
            {
                case Round::Phase::INIT: break;
                case Round::Phase::WAIT:
                    // TODO better
                    sendResponse(v, "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\n", flag == 2 ? "HTTPFiles/waiting.html" : "");
                    break;
                case Round::Phase::RUNNING:
                case Round::Phase::DONE:
                    // TODO better
                    sendResponse(v, "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\n", flag == 2 ? "HTTPFiles/running.html" : "");
                    break;
                case Round::Phase::CLOSED: break; // TODO
            }
        }
        return true;
    }
    return false;
}


bool ConnectionManager::sendResponse(Viewer* v, std::string header, std::string filename)
{
    if (!isValid(v))
    {
        return false;
    }
    if (!v->conn->send(header.data(), header.size()))
    {
        return !v->conn->connected();
    }
    if (filename != "")
    {
        std::ifstream f(filename, std::ios::binary | std::ios::ate);
        if (!f.is_open())
        {
            return true;
        }
        int filesize = (int)f.tellg();
        std::string contentSize = "Server: Toilet\r\nContent-Length: " + std::to_string(filesize) + "\r\n\r\n";
        if (!v->conn->send(contentSize.data(), contentSize.size()))
        {
            return true;
        }
        f.seekg(0);
        for (char buf[1024]; f.eof(); )
        {
            f.read(buf, 1024);
            if (!v->conn->send(buf, f.gcount()) && !v->conn->connected())
            {
                break;
            }
        }
        f.close();
        return true;
    }
    v->conn->send("Content-Length: 0\r\n\r\n", 21);
    return true;
}


bool ConnectionManager::playerGreeting(Viewer* v)
{
    if (!isValid(v))
    {
        return false;
    }
    std::string data = v->unusedData;
    data += v->conn->readall();
    std::string comp;
    comp.append("\0\0\0\x11\0\0\0\x01\0", 9);
    size_t p = data.find(comp);
    if (p == std::string::npos)
    {
        v->unusedData = data;
        return false;
    }
    data.erase(0, p+9);
    v->unusedData = data;
    if (Round::instance->map->nests.size() < players.size())
    {
        v->conn->send("\0\0\0\x0a\0\0\0\x01\0\0", 10); // OK
	return true;
    }
    v->conn->send("\0\0\0\x0a\0\0\0\x01\0\x01", 10); // DENY
    v->toClose = true;
    return false;
}


unsigned int getAGNPuint(std::string data)
{
    return ((unsigned int)data[0]<<24) + ((unsigned int)data[1]<<16) + ((unsigned int)data[2]<<8) + (unsigned int)data[3];
}


std::string ConnectionManager::makeAGNPuint(std::uint32_t num)
{
    std::string str;
    str.append((char)(num & 0xff));
    str.append((char)(num>>8 & 0xff));
    str.append((char)(num>>16 & 0xff));
    str.append((char)(num>>24 & 0xff));
    return str;
}


bool ConnectionManager::interpretRequests(Player* p)
{
    if (!isValid(p))
    {
        return false;
    }
    if (Round::instance->phase == Round::Phase::DONE || Round::instance->phase == Round::Phase::ERROR || Round::instance->phase == Round::Phase::CLOSED || Round::instance->phase == Round::Phase::INIT) 
    {
        return false;
    }
    std::string data = p->unusedData;
    data += p->conn->readall();
    if (messageSizeLeft == 0)
    {
        messageRequestsLeft = 0;
        if (data.length() >= 8)
        {
            messageSizeLeft = getAGNPuint(data) - 8;
            data.erase(0, 4);
            messageRequestsLeft = getAGNPuint(data);
            data.erase(0, 4);
        }
    }
    if (messageSizeLeft > 0 && data.length() >= messageSizeLeft)
    {
        p->timeAtLastMessage = std::chrono::steady_clock::now();
        std::string responses = "";
        std::uint32_t rq = 0;
        unsigned char unfinishedReq = 0;
        for (;messageRequestsLeft > 0; messageRequestsLeft--)
        {
            if (messageSizeLeft < 1)
            {
                break;
            }
            rq++;
            unsigned char id = data[0];
            data.erase(0, 1);
            messageSizeLeft -= 1;
            if (id == RequestID::BYE)
            {
                if (responses.length() > UINT32_MAX-10)
                {
                    std::string msg = "";
                    msg.append(makeAGNPuint(responses.length() + 8);
                    msg.append(makeAGNPuint(rq));
                    msg.append(responses);
                    p->conn->send(msg.c_str(), msg.length());
                    rq = 0;
                    responses = "";
                }
                responses.append("\x0203", 2);
                p->toClose = true;
                break;
            }
            else if (id == RequestID::JOIN)
            {
                if (responses.length() > UINT32_MAX-10)
                {
                    std::string msg = "";
                    msg.append(makeAGNPuint(responses.length() + 8);
                    msg.append(makeAGNPuint(rq));
                    msg.append(responses);
                    p->conn->send(msg.c_str(), msg.length());
                    rq = 0;
                    responses = "";
                }
                responses.append("\x0001", 2);
            }
            else if (id == RequestID::PING)
            {
                if (pinged)
                {
                    pinged = false; // This is of the only things the server does not respond to
                }
                else
                {
                    if (responses.length() > UINT32_MAX-10)
                    {
                        std::string msg = "";
                        msg.append(makeAGNPuint(responses.length() + 8);
                        msg.append(makeAGNPuint(rq));
                        msg.append(responses);
                        p->conn->send(msg.c_str(), msg.length());
                        rq = 0;
                        responses = "";
                    }
                    responses.append("\x0102", 2);
                }
            }
            else if (id == RequestID::SETTINGS)
            {
		std::string msg = "";
		msg.append(makeAGNPuint(responses.length() + 8);
		msg.append(makeAGNPuint(rq));
		msg.append(responses);
		p->conn->send(msg.c_str(), msg.length());
		rq = 0;
		responses = "";
		std::ifstream inf(RoundSettings::instance->configFile, std::ios::in | std::ios::ate);
		if (!inf.is_open())
		{
		    p->conn->send("\x0000000a000000010506", 10);
		}
		msg.clear();
		unsigned int configFileSize = inf.tellg();
		inf.seekg(0);
		p->conn->send(makeAGNPuint(configFileSize + 14) + "\x000000010505" + makeAGNPuint(configFileSize), 14);
		char buf[4096];
		unsigned int bytesSent = 0;
		for(;;)
		{
		    if (!inf.get(buf, 4096).fail())
		    {
			p->conn->send(buf, inf.gcount());
			bytesSent += inf.gcount();
		    }
		    else {break;}
		    if (inf.gcount() < 4096) {break;}
		}
		inf.close();
		break;}
            }
            else
            {
                bool endLoop = false;
                switch (Round::instance->phase)
                {
                    case Round::Phase::INIT:
                    case Round::Phase::DONE:
                    case Round::Phase::CLOSED:
                    case Round::Phase::ERROR:
                        endLoop = true;
                        break;
                    case Round::Phase::WAIT:
                        switch (id)
                        {
                            case RequestID::NAME:
				if (messageSizeLeft < 4)
				{
                                    unfinishedReq = id;
				    break;
				}
				std::uint32_t nameSize = getAGNPuint(data);
				messageSizeLeft -= 4;
				data.erase(0, 4);
				if (messageSizeLeft < nameSize)
				{
                                    unfinishedReq = id;
				    break;
				}
				p->name = data.substr(0, nameSize);
				data.erase(0, nameSize);
				messageSizeLeft -= nameSize;
				if (responses.length() > UINT32_MAX-10)
				{
				    std::string msg = "";
				    msg.append(makeAGNPuint(responses.length() + 8);
				    msg.append(makeAGNPuint(rq));
				    msg.append(responses);
                                    p->conn->send(msg.c_str(), msg.length());
                                    rq = 0;
                                    responses = "";
                                }
                                responses.append("\x0300", 2);
                                break;
			    default:
				if (responses.length() > UINT32_MAX-10)
				{
				    std::string msg = "";
				    msg.append(makeAGNPuint(responses.length() + 8);
				    msg.append(makeAGNPuint(rq));
				    msg.append(responses);
				    p->conn->send(msg.c_str(), msg.length());
				    rq = 0;
				    responses = "";
				}
				responses.append((char)id);
				responses.append('\x01');
                        }
                        break;
                    case Round::Phase::RUNNING:
                        switch (id)
                        {
                            case RequestID::TINTERACT:
                                if (messageSizeLeft < 9)
                                {
                                    break;
                                }
                                messageSizeLeft -= 9;
                                Command cmd;
                                cmd.nestID = p->nestID;
                                cmd.antID = data[0];
                                data.erase(0, 1);
                                cmd.cmd = Command::ID::TINTERACT;
                                cmd.arg = getAGNPuint(data);
                                cmd.arg<<=32;
                                data.erase(0, 4);
                                cmd.arg += getAGNPuint(data);
                                data.erase(0, 4);
                                commands.push_back(cmd);
                        }
                        break;
                }
                if (endLoop) {break;}
            }
        }
        data.erase(0, messageSizeLeft);
        messageSizeLeft = 0;
        if (rq > 0 && responses.length() > 0)
        {
            std::string msg = "";
            msg.append(makeAGNPuint(responses.length() + 8);
            msg.append(makeAGNPuint(rq));
            msg.append(responses);
            p->conn->send(msg.c_str(), msg.length());
        }
        if (unfinishedReq != 0)
        {
            std::string msg = ""; 
            msg.append("\x0000000a00000001", 8)
            msg.append((char)unfinishedReq);
            msg.append('\x01');
            p->conn->send(msg.data(), msg.length());
        }
    }
    unusedData = data;
    return true;
}
